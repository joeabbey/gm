#!/usr/bin/env node
'use strict';

const fs = require('fs');
const path = require('path');
const os = require('os');
const { spawnSync } = require('child_process');

const {
  loadPackages,
  loadPackagesForEditing,
  writePackages,
  getConfigPath
} = require('../lib/config');
const { runDoctor } = require('../lib/doctor');
const { readStatus, summarizeStatus } = require('../lib/status');
const { CLAUDE_PACKAGE, probeClaudeBinary } = require('../lib/claude');
const { version } = require('../package.json');

const ROOT = path.resolve(__dirname, '..');
const CHECK_SCRIPT = path.join(ROOT, 'scripts', 'check-updates.js');
const RENDER_SCRIPT = path.join(ROOT, 'scripts', 'render-message.js');
const DEFAULT_CACHE = path.join(os.homedir(), '.cache', 'gm', 'status.json');

function parseArgs(argv) {
  const args = argv.slice(2);
  return args;
}

function usage() {
  const text = `gm — Good morning ☕

Usage:
  gm [command]

Core workflow:
  gm status [options]          Human-friendly status report (default command)
  gm update                    Install/upgrade tracked npm globals
  gm packages [list]           Print the tracked package list

Prompt integration:
  gm prompt init [shell]       Print shell snippet to enable prompt integration (bash|zsh|fish)
  gm prompt tick [--quiet]     Refresh cache respecting the TTL and emit notices
  gm prompt tick --force       Force a refresh regardless of cache age

Package management:
  gm packages add <name...>    Add packages to the tracking set
  gm packages remove <name...> Remove packages from the tracking set

Diagnostics & utilities:
  gm doctor                    Diagnose environment issues
  gm check                     Run the update check immediately (always hits npm)
  gm render [--verbose]        Print the cached status payload
  gm --version | version       Print the current gm version
  gm help                      Show this message
`;
  process.stdout.write(text);
}

function resolveShell(args) {
  let shell = args.find((arg) => !arg.startsWith('-'));
  if (!shell) {
    const envShell = process.env.SHELL || '';
    shell = path.basename(envShell) || 'bash';
  }
  shell = shell.toLowerCase();
  if (shell.endsWith('zsh')) return 'zsh';
  if (shell.endsWith('fish')) return 'fish';
  return 'bash';
}

function promptSnippet(shell) {
  const promptDir = path.join(ROOT, 'share', 'gm');
  if (shell === 'fish') {
    return `# >>> gm initialize >>>\nif not set -q GM_ROOT\n    set -gx GM_ROOT "${ROOT}"\nend\nif test -f "$GM_ROOT/share/gm/prompt.fish"\n    source "$GM_ROOT/share/gm/prompt.fish"\nend\n# <<< gm initialize <<<`;
  }
  return `# >>> gm initialize >>>\nif [ -f "${promptDir}/prompt.sh" ]; then\n  GM_ROOT="\${GM_ROOT:-${ROOT}}"\n  . "${promptDir}/prompt.sh"\nfi\n# <<< gm initialize <<<`;
}

function formatTimestamp(isoString) {
  if (!isoString) {
    return 'unknown';
  }
  const parsed = new Date(isoString);
  if (Number.isNaN(parsed.getTime())) {
    return 'unknown';
  }
  return parsed.toLocaleString();
}

function runNodeScript(scriptPath, args = [], { quiet = false } = {}) {
  const env = { ...process.env, GM_CACHE: getCachePath() };
  const stdio = quiet ? ['ignore', 'ignore', 'inherit'] : 'inherit';
  const result = spawnSync(process.execPath, [scriptPath, ...args], {
    env,
    stdio
  });
  return result;
}

function runNodeCapture(scriptPath, args = []) {
  const env = { ...process.env, GM_CACHE: getCachePath() };
  const result = spawnSync(process.execPath, [scriptPath, ...args], {
    env,
    stdio: ['ignore', 'pipe', 'pipe']
  });
  return result;
}

function getCachePath() {
  return process.env.GM_CACHE && process.env.GM_CACHE.trim()
    ? process.env.GM_CACHE.trim()
    : DEFAULT_CACHE;
}

function getTtlSeconds() {
  const raw = process.env.GM_TTL_SECONDS;
  const parsed = raw ? Number.parseInt(raw, 10) : 21600;
  if (Number.isFinite(parsed) && parsed > 0) {
    return parsed;
  }
  return 0;
}

function cacheGeneratedAt(cachePath) {
  try {
    const raw = fs.readFileSync(cachePath, 'utf8');
    const data = JSON.parse(raw);
    if (data && typeof data.generatedAt === 'string') {
      const ts = Date.parse(data.generatedAt);
      if (!Number.isNaN(ts)) {
        return Math.floor(ts / 1000);
      }
    }
  } catch (error) {
    return null;
  }
  return null;
}

function ensureStatus({ force = false } = {}) {
  const cachePath = getCachePath();
  if (force) {
    runNodeScript(CHECK_SCRIPT, [], { quiet: true });
    return;
  }
  if (!fs.existsSync(cachePath)) {
    runNodeScript(CHECK_SCRIPT, [], { quiet: true });
    return;
  }
  const ttl = getTtlSeconds();
  if (ttl <= 0) {
    runNodeScript(CHECK_SCRIPT, [], { quiet: true });
    return;
  }
  const generated = cacheGeneratedAt(cachePath);
  if (!generated) {
    runNodeScript(CHECK_SCRIPT, [], { quiet: true });
    return;
  }
  const now = Math.floor(Date.now() / 1000);
  if (now - generated >= ttl) {
    runNodeScript(CHECK_SCRIPT, [], { quiet: true });
  }
}

function promptTick(args) {
  const quiet = args.includes('--quiet');
  const force = args.includes('--force');
  ensureStatus({ force });
  const renderArgs = [getCachePath()];
  if (quiet) {
    renderArgs.push('--quiet-when-none');
  }
  if (args.includes('--verbose')) {
    renderArgs.push('--verbose');
  }
  const result = runNodeCapture(RENDER_SCRIPT, renderArgs);
  if (result.error) {
    throw result.error;
  }
  if (result.status !== 0 && result.stderr) {
    process.stderr.write(result.stderr);
    process.exitCode = result.status;
    return;
  }
  if (result.stdout) {
    process.stdout.write(result.stdout);
  }
}

function gmStatus(args) {
  const wantsHelp = args.some((arg) => arg === '--help' || arg === '-h');
  if (wantsHelp) {
    console.log('Usage: gm status [--refresh] [--json] [--verbose]');
    console.log('  --refresh, -r  Force a fresh check before reporting');
    console.log('  --json         Emit raw JSON with summary details');
    console.log('  --verbose      Include missing packages when fully up to date');
    return;
  }
  const force = args.some((arg) => arg === '--refresh' || arg === '-r');
  const asJson = args.includes('--json');
  const verbose = args.includes('--verbose');
  ensureStatus({ force });
  const cachePath = getCachePath();
  const status = readStatus(cachePath);
  const summary = summarizeStatus(status);

  if (asJson) {
    const payload = {
      cachePath,
      generatedAt: status && status.generatedAt ? status.generatedAt : null,
      packages: status && Array.isArray(status.packages) ? status.packages : [],
      summary: {
        updates: summary.updates.map((pkg) => pkg.name),
        missing: summary.missing.map((pkg) => pkg.name),
        errors: summary.errors.map((pkg) => ({ name: pkg.name, error: pkg.error || 'lookup failed' }))
      }
    };
    process.stdout.write(`${JSON.stringify(payload, null, 2)}\n`);
    return;
  }

  console.log(`Cache: ${cachePath}`);
  console.log(`Last refresh: ${formatTimestamp(status && status.generatedAt)}`);
  const trackedCount = status && Array.isArray(status.packages)
    ? status.packages.length
    : loadPackages().length;
  console.log(`Tracked packages: ${trackedCount}`);

  if (!status) {
    console.log('Status: cache not generated yet. Run `gm check` to create it.');
    return;
  }

  if (summary.updates.length) {
    const formatted = summary.updates
      .map((pkg) => {
        const current = pkg.installed || 'none';
        const latest = pkg.latest || 'unknown';
        const viaNote = pkg.via === 'claude-cli' ? ' (via claude CLI)' : '';
        return `  - ${pkg.name}${viaNote} ${current} → ${latest}`;
      })
      .join('\n');
    console.log('Updates available:');
    console.log(formatted);
  } else {
    console.log('Updates available: none');
  }

  if (summary.errors.length) {
    const formatted = summary.errors
      .map((pkg) => {
        const viaNote = pkg.via === 'claude-cli' ? ' (via claude CLI)' : '';
        return `  - ${pkg.name}${viaNote}: ${pkg.error || 'lookup failed'}`;
      })
      .join('\n');
    console.log('Lookup issues:');
    console.log(formatted);
  } else {
    console.log('Lookup issues: none');
  }

  if (summary.missing.length) {
    const label = summary.updates.length || summary.errors.length || verbose
      ? 'Missing packages:'
      : 'Missing packages (install with `gm update`):';
    const formatted = summary.missing
      .map((pkg) => {
        const viaNote = pkg.via === 'claude-cli' ? ' (via claude CLI)' : '';
        return `  - ${pkg.name}${viaNote}`;
      })
      .join('\n');
    console.log(label);
    console.log(formatted);
  } else if (verbose) {
    console.log('Missing packages: none');
  }

  if (!summary.updates.length && !summary.errors.length && !summary.missing.length) {
    console.log('All packages are up to date.');
  }
}

function gmDoctor() {
  console.log('gm doctor report');
  const cachePath = getCachePath();
  const configPath = getConfigPath();
  const checks = runDoctor({ cachePath, configPath });
  const symbols = {
    ok: '[ok]',
    warn: '[warn]',
    error: '[error]',
    info: '[info]'
  };
  let hasError = false;
  checks.forEach((check) => {
    const prefix = symbols[check.status] || '[info]';
    console.log(`${prefix} ${check.name}: ${check.detail}`);
    if (check.status === 'error') {
      hasError = true;
    }
  });
  console.log(`Cache path: ${cachePath}`);
  console.log(`Config path: ${configPath}`);
  if (hasError) {
    process.exitCode = 1;
  }
}

function gmCheck() {
  const result = runNodeScript(CHECK_SCRIPT);
  if (result.error) {
    throw result.error;
  }
  process.exitCode = result.status;
}

function gmRender(args) {
  const result = runNodeScript(RENDER_SCRIPT, args);
  if (result.error) {
    throw result.error;
  }
  process.exitCode = result.status;
}

function gmUpdate() {
  const packages = loadPackages();
  if (!packages.length) {
    console.error('gm: no packages configured.');
    process.exitCode = 1;
    return;
  }
  const claudeProbe = probeClaudeBinary();
  const npmPackages = [];
  let invokedClaude = false;

  packages.forEach((pkg) => {
    if (pkg === CLAUDE_PACKAGE && claudeProbe && claudeProbe.found) {
      invokedClaude = true;
    } else {
      npmPackages.push(pkg.includes('@') ? pkg : `${pkg}@latest`);
    }
  });

  let npmStatus = 0;
  if (npmPackages.length) {
    const args = ['install', '-g', ...npmPackages];
    const result = spawnSync('npm', args, { stdio: 'inherit' });
    if (result.error) {
      throw result.error;
    }
    npmStatus = result.status;
    if (npmStatus !== 0) {
      process.exitCode = npmStatus;
      return;
    }
  }

  if (invokedClaude) {
    const claudeResult = spawnSync('claude', ['update'], { stdio: 'inherit' });
    if (claudeResult.error) {
      throw claudeResult.error;
    }
    if (claudeResult.status !== 0) {
      process.exitCode = claudeResult.status;
      return;
    }
  }

  process.exitCode = npmStatus;
}

function gmPackagesAdd(rawNames) {
  if (!rawNames.length) {
    console.error('gm: packages add requires at least one package name.');
    process.exitCode = 1;
    return;
  }
  const parsedNames = [];
  const seen = new Set();
  for (const raw of rawNames) {
    const name = typeof raw === 'string' ? raw.trim() : '';
    if (!name) {
      console.error('gm: package name cannot be empty.');
      process.exitCode = 1;
      return;
    }
    if (seen.has(name)) {
      continue;
    }
    seen.add(name);
    parsedNames.push(name);
  }
  let result;
  try {
    result = loadPackagesForEditing();
  } catch (error) {
    console.error(`gm: ${error.message}`);
    process.exitCode = 1;
    return;
  }
  const { packages, configPath } = result;
  const existing = new Set(packages);
  const added = [];
  for (const name of parsedNames) {
    if (existing.has(name)) {
      continue;
    }
    packages.push(name);
    existing.add(name);
    added.push(name);
  }
  if (!added.length) {
    console.log('gm: nothing to add.');
    return;
  }
  try {
    writePackages(configPath, packages);
    console.log(`gm: added ${added.join(', ')} (${configPath})`);
  } catch (error) {
    console.error(`gm: failed to write ${configPath}: ${error.message}`);
    process.exitCode = 1;
    return;
  }
  if (process.env.GM_AUTO_REFRESH_ON_EDIT !== '0') {
    const refresh = runNodeScript(CHECK_SCRIPT, [], { quiet: true });
    if (refresh && refresh.status !== 0) {
      console.error('gm: status refresh encountered an error.');
    }
  }
}

function gmPackagesRemove(rawNames) {
  if (!rawNames.length) {
    console.error('gm: packages remove requires at least one package name.');
    process.exitCode = 1;
    return;
  }
  const parsedNames = [];
  const target = new Set();
  for (const raw of rawNames) {
    const name = typeof raw === 'string' ? raw.trim() : '';
    if (!name) {
      console.error('gm: package name cannot be empty.');
      process.exitCode = 1;
      return;
    }
    if (target.has(name)) {
      continue;
    }
    target.add(name);
    parsedNames.push(name);
  }
  let result;
  try {
    result = loadPackagesForEditing();
  } catch (error) {
    console.error(`gm: ${error.message}`);
    process.exitCode = 1;
    return;
  }
  const { packages, configPath } = result;
  const remaining = [];
  const removed = [];
  for (const pkg of packages) {
    if (target.has(pkg)) {
      removed.push(pkg);
      continue;
    }
    remaining.push(pkg);
  }
  if (!removed.length) {
    console.log('gm: nothing to remove.');
    return;
  }
  try {
    writePackages(configPath, remaining);
    console.log(`gm: removed ${removed.join(', ')} (${configPath})`);
  } catch (error) {
    console.error(`gm: failed to write ${configPath}: ${error.message}`);
    process.exitCode = 1;
    return;
  }
  if (process.env.GM_AUTO_REFRESH_ON_EDIT !== '0') {
    const refresh = runNodeScript(CHECK_SCRIPT, [], { quiet: true });
    if (refresh && refresh.status !== 0) {
      console.error('gm: status refresh encountered an error.');
    }
  }
}

function gmPackages(args) {
  if (!args.length) {
    const packages = loadPackages();
    packages.forEach((pkg) => process.stdout.write(`${pkg}\n`));
    return;
  }
  const sub = args[0];
  if (sub === 'add') {
    gmPackagesAdd(args.slice(1));
    return;
  }
  if (sub === 'remove') {
    gmPackagesRemove(args.slice(1));
    return;
  }
  if (sub === 'list' || sub === 'ls') {
    const packages = loadPackages();
    packages.forEach((pkg) => process.stdout.write(`${pkg}\n`));
    return;
  }
  console.error(`gm: unsupported packages subcommand "${sub || ''}".`);
  process.exitCode = 1;
}

function main() {
  const args = parseArgs(process.argv);
  const command = args[0];

  if (!command) {
    gmStatus([]);
    return;
  }

  if (command === 'help' || command === '--help' || command === '-h') {
    usage();
    return;
  }

  if (command === '--version' || command === '-v' || command === 'version') {
    console.log(version);
    return;
  }

  if (command === 'prompt') {
    const sub = args[1];
    if (sub === 'init') {
      const shell = resolveShell(args.slice(2));
      process.stdout.write(`${promptSnippet(shell)}\n`);
      return;
    }
    if (sub === 'tick') {
      promptTick(args.slice(2));
      return;
    }
    console.error(`gm: unsupported prompt subcommand "${sub || ''}".`);
    process.exitCode = 1;
    return;
  }

  if (command === 'check') {
    gmCheck();
    return;
  }

  if (command === 'render') {
    gmRender(args.slice(1));
    return;
  }

  if (command === 'status') {
    gmStatus(args.slice(1));
    return;
  }

  if (command === 'update') {
    gmUpdate();
    return;
  }

  if (command === 'packages') {
    gmPackages(args.slice(1));
    return;
  }

  if (command === 'doctor') {
    gmDoctor();
    return;
  }

  console.error(`gm: unknown command "${command}".`);
  process.exitCode = 1;
}

main();
